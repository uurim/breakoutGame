<!DOCTYPE html>
<html>
    <head>
        <title>Breakout Game</title>
        <link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&display=swap" rel="stylesheet">
        <style>
            body {
                height : 100%;
                font-family: 'Alfa Slab One', cursive;
                text-align : center;
                background: url(img/back.jpg);
            }
            h1 {
                color:  #9F81F7;
                font-size: 3em;
                text-shadow : 2px 2px 3px #000;
                margin-top : 20px;
            }
            h1 span {
                margin-top : 20px;
                color: #FA5882;
            }
            #stage {
                width: 500px;
                height: 50px;
                margin: 20px auto;
                font-size: 3em;
                text-align: center;
                color: #FA5882;
                text-shadow : 2px 2px 3px #000;
            }

            #score {
                width: 500px;
                height: 50px;
                margin: 30px auto;
                font-size: 4em;
                text-align: center;
                color: #F3F781;
                text-shadow : 2px 2px 3px #000;
            }
            #board {
                position : relative;
                margin: 50px auto;
                width : 700px;
                height : 600px;
                border: 6px solid #08298A;
                box-shadow: 0 0 1px rgba(0,0,0,0.2);
                background-color : #0B2161;
                z-index: 0;
            }
            #bar {
                position: absolute;
                width : 120px;
                height : 15px;
                border-radius: 10px;
                z-index : 110;
                background-color:#A9F5E1;
            }
            #ball {
                position: absolute;
                width : 20px;
                height : 20px;
                border-radius: 10px;
                background-color: #F3F781;
                z-index: 100;
            }
            .brick {
                position : absolute;
                width : 68px;
                height : 28px;
                background-color : #9F81F7;
                border : 1px solid #8258FA;
                z-index: 50;
            }
            .lightning {
                position: absolute;
                width: 32px;
                height: 50px;
                background : url(img/lightning.png);
                z-index: 20;
            }
            .raindrop {
                position : absolute;
                width: 23px;
                height: 31px;
                background : url(img/raindrop.png);
            }
            .cloud {
                position : absolute;
                width : 149px;
                height: 82px;
                background : url(img/cloud.png);
                z-index: 400;
            }
            #gameOver {
                display: none;
                position: absolute;
                top: 150px;
                left: 200px;
                width: 300px;
                height: 300px;
                color: #F3F781;
                background-color:#08298A;
                border: 2px solid #9F81F7;
                border-radius: 8px;
                z-index: 500;
                letter-spacing : 3px;
                font-size: 20px;
            }
        </style>
        <script>
            /*
                Breakout Game (벽돌깨기게임)
                하단의 막대를 좌우로 움직이면서 공을 튕겨 벽돌을 깨면 포인트가 올라가는 게임,
                공을 놓치거나 빗방울을 먹으면 게임이 종료된다.
                아이템 : 
                    - 벽돌 : 공으로 깨면 10point +
                    - 번개 : 막대로 먹으면 5point +
                    - 빗방울 : 막대로 먹으면 게임 종료
                    - 구름 : 랜덤 위치에 불투명 구름이 지나가면서 시각방해
                    - 눈사람 : 마지막 스테이지 벽돌 한개 남았을 때 랜덤위치 등장
                                먹으면 눈사람포인트 흭득하면서 게임 종료
                                제한 시간 내에 먹지 못하면 실패로 게임 종료
                단계 :
                    1 - 벽돌
                    2 - 번개
                    3 - 빗방울
                    4 - 구름
                    5 - 눈사람
                효과음 :
                    - 벽돌로 포인트 흭득
                    - 번개로 포인트 흭득
                    - 빗방울/공에 의한 게임 종료
                    - 스노우맨에 의한 게임 종료
                입력 :
                    - 키 이벤트 : 화살표 키로 막대 이동
                게임 종료 시 최고 점수 top3 보여준다.
            */
            const STEP = 8;
            const GAP = 5;
            const BRICK_POINT = 10;
            const LIGHTNING_POINT = 5;
            const SCORE_ARRAY = 'breackoutGameScores';
            const MAX_SCORES = 3;

            // 윈도우 로드가 완료되면 요소들을 불러온 뒤 필요한 객체를 정의한다.
            window.onload = function(){
                let barElement = document.getElementById('bar');
                let boardElement = document.getElementById('board');
                let ballElement = document.getElementById('ball');
                let scoreElement = document.getElementById('score');
                let stageElement = document.getElementById('stage');
                
                let bar = new Bar(barElement, STEP);
                let ball = new Ball(ballElement, STEP, boardElement, bar);
                let board = new Board(boardElement, bar, ball, scoreElement, stageElement);
            };

            /*
            막대, 공, 벽돌(배열), 번개, 빗방울, 구름, 눈사람, 보드의 객체 정의하였습니다.
            보드에서 벽돌, 번개, 빗방울, 구름, 눈사람을 만든 뒤 막대 또는 공과 비교, 삭제하고
                    사운드 플레이, 스코어/스테이지 업데이트, 게임 종료, Top 3 표시를 진행하였습니다.
            */


            /************------------------------ BAR ----------------------************/
            function Bar(element, step) {
                this.element = element;
                this.step = step;

                /* 막대 초기 설정 */
                this.init = function() {
                    //초기 위치 지정
                    this.element.style.top = '585px';
                    this.element.style.left = '290px';
                    //게임 오버 시에 true로 바꿔줄 프로퍼티
                    this.gameOver = false;
                    
                    //키이벤트 실행
                    this.registerEvents();
                };

                /* 혹시 다른 곳에서 쓰지 않아도 오류가 안 나도록 추가 */
                this.onMove = function(){
                };

                /* 막대 움직이는 함수 */
                this.registerEvents = function() {
                    let self = this;
                    document.addEventListener('keydown', function(e){
                        // 게임 오버되면 true로 바뀌면서 키이벤트 실행 안 됨
                        if (self.gameOver == true) return;
                        // 게임 오버는 아니지만 좌우 방향키가 아닐 시 실행 안 됨
                        if ((e.keyCode =! 37) || (e.keycode =! 39)) return;
                        // 좌우 방향키 클릭 시 각각 좌우로 이동하는 메소드 실행
                        if (e.keyCode == 37) {
                            self.moveLeft();
                        }
                        else if (e.keyCode == 39) {
                            self.moveRight();
                        }
                        // 막대가 움직이는 동안 움직인다는 것 알리는 메소드 실행
                        self.onMove();
                    });
                };

                /* 좌우 이동 메소드 */
                this.moveLeft = function(){
                    //스타일값을 정수로 바꾼 뒤 step을 더하고 다시 px를 붙여줌
                    this.element.style.left = (parseInt(this.element.style.left) - this.step) + 'px';
                };
                this.moveRight = function(){
                    //좌 이동과 같은 방식이나 우측으로 이동해야 하므로 step을 더해줌
                    this.element.style.left = (parseInt(this.element.style.left) + this.step) + 'px';
                };

                /* 게임오버되면 보드에서 실행할 메소드 */
                this.ignoreKeyEvents = function(){
                    //키이벤트에서 실행되도록 true로 변경
                    this.gameOver = true;
                }

                /* 요소의 위치를 알기 위한 사각형을 반환해주는 메소드 */
                this.getRectangle = function(){
                        return this.element.getBoundingClientRect();
                    }

                /* 초기설정실행 */
                this.init();
            }

            /************------------------------ BALL ----------------------************/
            function Ball(element, step, container, bar) {
                this.element = element;
                this.step = step;
                this.container = container;
                this.topDirection = -1;
                this.leftDirection = -1;
                this.bar = bar;


                /* 공 초기 설정*/
                this.init = function(){
                    // 공 위치 지정
                    this.element.style.top = '550px';
                    this.element.style.left = '330px';

                    // 타이머 안에서는 this가 공으로 인식 안 되기 때문에 self에 미리 넣어줌
                    let self = this;
                    // 보드와 공을 비교해주어야 하므로 각각의 사각형을 가져옴
                    let boardRec = this.container.getBoundingClientRect(); //getBoundingClientRect()가 사각형을 반환해주는 함수
                    let ballRec = this.getRectangle();

                    /* 공이 계속 움직이도록 타이머를 설정하는 메소드 */
                    this.ballTimerId = setInterval(function(){
                        // 보드와 비교할 left와 top 값을 넣어준다.
                        let left = parseInt(self.element.style.left);
                        let top = parseInt(self.element.style.top);

                        /*
                        기본적으로 보드에서 튕겨지는 움직임을 만들기
                        공이 좌우에 부딪히면 상하의 방향을 바꿔주면 되고
                        공이 상하에 부딪히면 좌우의 방향을 바꿔주면 된다.
                        Direction을 가야하는 방향에 따라 음수와 양수로 바꾸어 더하려는 위치값에 곱해준다.
                        */
                        if (top < 5) { //윗면에 부딪히면 아래로
                            self.topDirection = 1;
                        } else if (left < 5) { //왼쪽면에 부딪히면 오른쪽으로
                            self.leftDirection = 1;
                        } else if (left + ballRec.width > boardRec.width - 5) {
                            //오른쪽면에 부딪히면 왼쪽으로
                            self.leftDirection = -1;
                            //아랫면은 위쪽으로 설정하는데 보드와 부딪히면 게임오버이므로 막대로 바꿔준다.
                        } else if (self.isOverlapped()){
                            self.topDirection = -1;
                        }
                        /* 벽돌과 부딪히면 보드에서 반환해주는 bumpedSide 값에 따라 방향 바꾸는 메소드 */
                        self.changeDirection = function(bumpedSide) {
                            if (bumpedSide == 'top') { //공의 윗면이 부딪힌 경우
                                self.topDirection = 1; 
                            }
                            else if (bumpedSide == 'bottom') { //공의 아랫면이 부딪힌 경우
                                self.topDirection = -1;
                            }
                            /* left와 right의 경우 벽돌의 네 귀퉁이에서 leftDirection의 1일 때와 -1일 때가 겹치는 부분을 처리해야 한다.
                            예를 들어, 기본적으로 left는 동쪽에서 오는 공의 왼쪽면이 부딪히는 경우로 leftDirection이 바뀌도록 처리한다.
                            하지만 left는 남동쪽에서 오는 공과 남서쪽에서 오는 공이 같은 벽돌의 오른쪽아래 모서리에서 겹칠 수 있는데
                            이 때 남서쪽에서 오는 공은 topDirection이 바뀌도록 해주어야 한다. 해당 부분을 top에서 처리하도록 작성하면 
                            남동쪽에서 오는 공이 또다시 top에서 겹치는 것과 마찬가지이니 topDirection을 달리하는 방식으로 구분하였다.
                            */
                            else if (bumpedSide == 'left'){
                                if (self.topDirection == 1 && self.leftDirection == 1) {
                                    self.topDirection = -1;
                                }
                                else if (self.topDirection == -1 && self.leftDirection == 1) {
                                    self.topDirection = 1;
                                }
                                else {
                                    self.leftDirection = 1;
                                }
                            }
                            else if (bumpedSide == 'right'){
                                if (self.topDirection == -1 && self.leftDirection == -1) {
                                    self.topDirection = 1;
                                }
                                else if (self.topDirection == 1 && self.leftDirection == -1) {
                                    self.topDirection = 1;
                                }
                                else {
                                    self.leftDirection = -1;
                                }
                            }
                        };

                        // 위치가 어느 방향으로 갈 것인지 스텝에 방향을 곱해줌
                        let leftPosition = left + self.leftDirection * self.step;
                        let topPosition = top + self.topDirection * self.step;

                        // 최종적으로 정해진 위치를 스타일에 등록해줌
                        self.element.style.left = leftPosition + 'px';
                        self.element.style.top = topPosition + 'px';
                    
                        // 공이 움직이는 동안 알려주기 위해 실행
                        self.onMove();
                    }, 60);
                
                }

                /* 게임 오버되면 타이머를 clear하여 멈추는 메소드 */
                this.stop = function(){
                    clearInterval(this.ballTiemrId);
                }

                /* 오류 나지 않도록 추가 */
                this.onMove = function(){
                }

                /* 막대와 공이 겹치는지 확인하는 메소드 */
                this.isOverlapped = function(){
                    let ballRec = this.getRectangle();
                    let barRec = this.bar.getRectangle();
                    let radius = ballRec.left + ballRec.width*0.5
                    if (barRec.top -5 < ballRec.bottom) {
                        if (radius > barRec.left && radius < barRec.right) {
                            return true;
                        }
                    }
                }

                /* 요소의 사각형 반환 메소드 */
                this.getRectangle = function(){
                        return this.element.getBoundingClientRect();
                }

                /* 초기 설정 실행 */
                this.init();
            };

            /************------------------------ BRICK ----------------------************/
            function Brick(container) {
                this.container = container;
                this.brickTopElements = [];
                this.brickLeftElements = [];
                this.randomindexTop = 0;
                this.randomindexLeft = 0;
                this.bricks = [];

                this.init = function() {
                    //벽돌이 나올 수 있는 위치 배열
                    brickTopElements = ['0px', '30px', '60px', '90px', '120px', '150px', '180px'];
                    brickLeftElements = ['0px', '70px', '140px', '210px', '280px', '350px', '420px', '490px',
                                            '560px', '630px'];

                    /* 스테이지에 따라 벽돌 개수를 달리 생성하는 메소드 */
                    this.appendBricks = function(stage){
                        for (let i = 0; i < stage+5; i += 1){
                            //벽돌 요소 생성 메소드 실행
                            let brick = this.appendBrick();

                            //배열에 추가
                            this.bricks.push(brick);
                        }
                        
                        //만들어진 벽돌 배열을 리턴해줌
                        return this.bricks;
                    }
                };

                /* 벽돌 요소 하나를 만드는 메소드 */
                this.appendBrick = function(){
                    //요소와 속성을 만든 뒤
                    this.element = document.createElement('div');
                    this.element.setAttribute('class', 'brick');
                    //위치를 랜덤으로 골라 바꿔주고
                    this.element.style.top = brickTopElements[randomRange(0,brickTopElements.length-1)];
                    this.element.style.left = brickLeftElements[randomRange(0,brickLeftElements.length-1)];
                    //태그를 하위요소로 추가해줌
                    this.container.appendChild(this.element);

                    return this.element;
                };

                /* 초기 설정 실행 */
                this.init();
            }

            /************--------------------- LIGHTNING -------------------************/
            function Lightning(container, step) {
                this.container = container;
                this.step = step;

                /* 번개 초기 설정 */
                this.init = function() {
                    //번개 요소 만들기
                    this.element = document.createElement('div');
                    this.element.setAttribute('class', 'lightning');

                    this.element.style.top = randomRange(150, 300) + 'px';
                    this.element.style.left = randomRange(0, 650) + 'px';
                        
                    this.container.appendChild(this.element);

                    let self = this;
                    /* 번개 움직임 만드는 메소드 */
                    this.lightningTimerId = setInterval(function(){
                        let boardRec = self.container.getBoundingClientRect();
                        let lightningRec  = self.getRectangle();
                        //위에서 아래로 낙하하는 움직임을 위해 top에 스텝을 더해줌
                        let topPosition = parseInt(self.element.style.top) + self.step;
                        //보드 밖으로 나가면 없어지기
                        if (lightningRec.bottom > boardRec.bottom - 10) {
                            //타이머를 멈추고 요소를 제거함
                            clearInterval(self.lightningTimerId);
                            self.remove();
                        }
                        //밖으로 나가지 않는 동안은 top을 적용시킴
                        else {
                            self.element.style.top = topPosition + 'px';
                            // 움직이는 동안 onMove를 실행시키면서 요소의 사각형을 넘겨줌
                            self.onMove(self.getRectangle());
                        }
                    }, 130);
                };
                
                /* 요소를 제거하고 onDie를 실행시켜서 배열에서 제거하는 메소드 */
                this.remove = function() {
                    //타이머를 clear하고
                    clearInterval(this.lightningTimerId);
                    //요소 제거
                    this.element.remove();
                    //배열에서 제거
                    this.onDie();
                }

                /* 타이머를 clear해서 모두 정지되도록 하는 메소드 */
                this.stop = function(){
                    clearInterval(this.lightningTimerId);
                }

                /* onMove 오류 안 나도록 추가 */
                this.onMove = function(clientRect) {
                };

                /* onDie 오류 안 나도록 추가 */
                this.onDie = function() {
                }

                /* 요소 사각형 반환 메소드 */
                this.getRectangle = function(){
                    return this.element.getBoundingClientRect();
                }

                // 초기 설정 실행
                this.init();
            }


            /************---------------------- RAINDROP ----------------------************/
            function Raindrop(container, step) {
                this.container = container;
                this.step = step;

                this.init = function() {
                    // 빗방울 요소 만들어서 추가하기
                    this.element = document.createElement('div');

                    this.element.setAttribute('class', 'raindrop');

                    this.element.style.top = randomRange(200, 300) + 'px';
                    this.element.style.left = randomRange(300, 650) + 'px';

                    container.appendChild(this.element);


                    let self = this;
                    /* 빗방울 움직이는 타이머 설정하는 메소드 */
                    this.RaindropTimerId = setInterval(function(){

                        let boardRec = self.container.getBoundingClientRect();
                        let RaindropRec  = self.getRectangle();

                        //비스듬히 왼쪽으로 내려가도록 설정
                        let topPosition = parseInt(self.element.style.top) + self.step;
                        let leftPosition = parseInt(self.element.style.left) - self.step + 4;
                        
                        //밑으로 나가거나 왼쪽으로 나가면 제거되도록 설정
                        if (RaindropRec.bottom > boardRec.bottom - GAP || leftPosition < 5) {
                            clearInterval(self.RaindropTimerId);
                            self.remove();
                        } else {
                            self.element.style.left = leftPosition + 'px';
                            self.element.style.top = topPosition + 'px';
                            //움직이는 동안 실행을 알림
                            self.onMove(self.getRectangle());
                        }
                    }, 250);
                };

                /* 제거 메소드 */
                this.remove = function(){
                    clearInterval(this.timerId);
                    this.element.remove();
                    this.onDie();
                };

                /* 멈추는 메소드 */
                this.stop = function(){
                    clearInterval(this.RaindropTimerId);
                }

                /* 오류 안 나게 추가 */
                this.onMove = function() {
                }
                this.onDie = function() {
                }

                /* 요소 사각형 반환 메소드 */
                this.getRectangle = function(){
                        return this.element.getBoundingClientRect();
                }

                // 초기 설정 실행
                this.init();
            }

            /************--------------------- CLOUD -------------------************/
            function Cloud(container, step, opacity) {
                this.container = container;
                this.step = step;
                this.opacity = opacity;

                /* 구름 초기 설정 */
                this.init = function() {

                    //구름 요소 만들기
                    this.element = document.createElement('div');
                    this.element.setAttribute('class', 'cloud');

                    // 왼쪽에서 나타나도록 랜덤위치 설정
                    this.element.style.top = randomRange(300, 500) + 'px';
                    this.element.style.left = randomRange(0, 50) + 'px';
                    //투명도 랜덤으로 값 받기
                    this.element.style.opacity = this.opacity;

                    this.container.appendChild(this.element);

                    let self = this;
                    this.cloudTimerId = setInterval(function(){
                        //오른쪽으로만 이동하도록 설정
                        let leftPosition = parseInt(self.element.style.left) + self.step;
                        //보드 오른쪽으로 넘어가면 제거
                        if (leftPosition + self.getRectangle().width > self.container.getBoundingClientRect().width -5) {
                            self.element.remove();
                            clearInterval(self.cloudTimerId);
                        } else {
                            //위치 적용
                            self.element.style.left = leftPosition + 'px';
                        }
                    }, 200);
                };

                /* 제거 메소드 */
                this.remove = function() {
                    clearInterval(this.cloudTimerId);
                    this.element.remove();
                }

                /* 정지 메소드 */
                this.stop = function(){
                    clearInterval(this.cloudTimerId); 
                }

                /* 요소 사각형 반환 메소드 */
                this.getRectangle = function(){
                    return this.element.getBoundingClientRect();
                }

                //초기 설정 실행
                this.init();
            }

            /************--------------------- SNOWMAN -------------------************/
            function Snowman(container){
                this.container = container;

                this.init = function(){
                    // 눈사람 만들기
                    this.element = document.createElement('div');
                    this.element.setAttribute('class','snowman');
                    
                    //보드의 바닥에 랜덤으로 생기는 위치 지정
                    this.element.style.left = randomRange(5, 610) + 'px';
                    this.element.style.top = '515px';
                    //깜빡임을 위해 display 설정
                    this.element.style.display = 'block';

                    this.container.appendChild(this.element);

                    let self = this;
                    /* 깜빡임을 시작하는 타이머 메소드 */
                    this.blinkStartTimer = setTimeout(function(){
                        /* 깜빡임을 수행하는 타이머 메소드 */
                        self.blinkTimer = setInterval(function(){
                            // 만약 안 보이면 보이도록 보이면 안 보이도록 설정
                            if (self.element.style.display == 'none'){
                                self.element.style.display = 'block';
                            } else {
                                self.element.style.display = 'none';
                            } 
                        }, 300);
                    }, 2000);
                    /* 시간 내에 먹지 못하면 게임 오버 */
                    this.gameOverTimer = setTimeout(function(){
                        self.timeout();
                    }, 3000)
                };

                /* 오류 안 나게 추가 */
                this.timeout = function() {
                };

                /* 요소 사각형 반환 메소드 */
                this.getRectangle = function() {
                    return this.element.getBoundingClientRect();
                }

                /* 제거 메소드 */
                this.remove = function(){
                    this.element.remove();
                    this.clearTimers();
                }

                /* 타이머 clear 메소드 */
                this.clearTimers = function(){
                    //깜빡임을 멈추기
                    clearInterval(this.blinkTimer);
                    //실행되기 전이라면 실행되지 않도록
                    clearTimeout(this.blinkStartTimer);
                    clearTimeout(this.gameOverTimer);
                }
                
                //초기 설정 실행
                this.init();
            }
            
            
            /************------------------------ BOARD ----------------------************/
            function Board(element, bar, ball, scoreElement, stageElement) {
                this.element = element;
                this.bar = bar;
                this.ball = ball;
                this.scoreElement = scoreElement;
                this.stageElement = stageElement;
                this.bricks = [];
                this.raindrops = [];
                this.lightnings = [];
                this.clouds = [];
                this.cloudOpacitys = [];
                this.snowman = null;

                /* 보드 초기 설정 */
                this.init = function(){
                    this.score = 0;
                    this.stage = 1;

                    let self = this;
                    this.makeBricks(); //벽돌 생성
                    
                    // 필요한 오디오 불러오기
                    this.bounceAudio = document.getElementsByClassName('ball')[0];
                    this.eatAudio = document.getElementsByClassName('item')[0];
                    this.failAudio = document.getElementsByClassName('fail')[0];
                    this.endingAudio = document.getElementsByClassName('ending')[0];
                    
                    /* 공이 움직일 때 */
                    this.ball.onMove = function(){
                        //만들어진 벽돌 배열을 돌면서
                        for (let i = 0; i < self.bricks.length; i+=1){
                            //벽돌의 사각형을 만들고
                            let rectangle = self.bricks[i].getBoundingClientRect();
                            //만약 공과 벽돌이 부딪혔다면
                            if (self.isOverlappedByBall(rectangle)) {
                                //겹친 벽돌 제거
                                self.bricks[i].remove();
                                
                                //bounce 사운드
                                self.bounceAudio.currentTime = 0;
                                self.bounceAudio.play();

                                //벽돌 배열에서 제거
                                self.bricks.splice(i,1);

                                //점수 추가
                                self.updateScore(BRICK_POINT);

                                break;
                            }
                        }

                        //공이 바닥에 닿으면 fail 사운드, 게임 오버
                        let boardRec = self.getRectangle();
                        let ballRec = this.getRectangle();
                        if (boardRec.bottom - 10 < ballRec.bottom) {
                            self.failAudio.play();
                            self.gameOver();
                        }
                    }

                    // 막대가 움직이는 동안 움직이지 않는 눈사람과 비교
                    this.bar.onMove = function(){
                        // 눈사람이 생성되었고 눈사람과 막대가 겹쳤다면 ending 사운드, 점수 추가, 게임 오버
                        if ((self.snowman != null) && (self.isOverlappedByBar(self.snowman.getRectangle()))){   
                            self.endingAudio.play();
                            self.updateScore(SNOWMAN_POINT);
                            self.gameOver();
                        }
                    };
                };

                /* 공과 벽돌 겹치는지 확인 메소드 */
                this.isOverlappedByBall = function(clientRect) {
                    let ballRect = this.ball.getRectangle();

                    // 겹치지 않는 경우 모두 false
                    if (ballRect.right < clientRect.left + GAP) return false;
                    if (ballRect.left > clientRect.right - GAP) return false;
                    if (ballRect.bottom < clientRect.top + GAP) return false;
                    if (ballRect.top > clientRect.bottom - GAP) return false;

                    // 겹쳤다면 겹친 부분 확인하는 메소드에 비교할 요소들을 넣어 부딪힌 면을 받고
                    let bumpedSied = this.sideOverlapped(ballRect, clientRect);
                    // 공의 방향을 바꾸는 메소드로 부딪힌 면을 보내준다.
                    this.ball.changeDirection(bumpedSied);

                    return true;
                };

                /* 공과 벽돌 겹치는 부분 확인 메소드 */
                this.sideOverlapped = function(ballRect, clientRect) {
                    let ballRadius = ballRect.width*0.5;
                    let brickRadius = clientRect.height*0.5;
                    
                    //공의 중심이 벽돌의 left와 right 사이에 있는 경우는 top, bottom으로 처리함
                    if ((ballRect.left + ballRadius <= clientRect.right) &&
                        (ballRect.left + ballRadius >= clientRect.left)) {
                        //공의 bottom이 벽돌 height의 반보다 위에 있으면 공의 아랫면이 부딪힌 것으로
                        if (ballRect.bottom <= clientRect.top + brickRadius) {
                            return 'bottom';
                        }
                        //그렇지 않으면 공의 윗면이 부딪힌 것으로 처리함
                        else {
                            return 'top';
                        }
                    }
                    //공의 중심이 벽돌의 양 바깥 쪽에 있는 경우
                    //공의 left가 벽돌 left의 왼쪽에 있으면 공의 오른쪽면이 부딪힌 것으로
                    else if (ballRect.left < clientRect.left) {
                        return 'right';
                    }
                    //그렇지 않으면 오른쪽면이 부딪힌 것으로 처리함
                    else {
                        return 'left';
                    }
                };

                /* 벽돌 만들기 */
                this.makeBricks = function(){
                    // 벽돌 객체를 정의한 후
                    let brick = new Brick(this.element);
                    // 현재 스테이지를 인자로 보내서 스테이지에 맞는 벽돌 배열을 받음
                    this.bricks = brick.appendBricks(this.stage);
                };

                /* 번개 만들기 */
                this.makeLightning = function(){
                    let self = this;
                    /* 번개 연속 생성 타이머 설정 메소드 */
                    this.lightningTimerId = setInterval(function(){
                        // 번개 객체를 정의한 후
                        let lightning = new Lightning(self.element, STEP);
                        
                        // 번개 움직일 때
                        lightning.onMove = function(clientRect) {
                            // 막대랑 겹치면 번개 제거, 스코어 추가, eat 사운드
                            if (self.isOverlappedByBar(clientRect)) {
                                lightning.remove();
                                self.updateScore(LIGHTNING_POINT);
                                self.eatAudio.currentTime = 0;
                                self.eatAudio.play();
                            }
                        };

                        // 번개 배열에서 제거하는 메소드
                        lightning.onDie = function() {
                            for (let i = 0; i < self.lightnings.length ; i += 1){
                                if (self.lightnings[i] == lightning) {
                                    self.lightnings.splice(i,1);
                                    break;
                                }
                            }
                        }
                        
                        // 새로 만든 번개는 배열에 추가
                        self.lightnings.push(lightning);
                        
                    }, randomRange(3000, 8000));
                };
                
                /* 빗방울 만들기 */
                this.makeRaindrop = function(){
                    let self = this;
                    /* 빗방울 연속 생성 타이머 설정 메소드 */
                    this.raindropTimerId = setInterval(function(){
                        // 빗방울 객체를 정희한 후
                        let raindrop = new Raindrop(self.element, STEP+10)
                        // 빗방울이 움직일 때
                        raindrop.onMove = function(clientRect) {
                            //빗방울과 막대가 부딪히면 fail 사운드, 게임 오버
                            if (self.isOverlappedByBar(clientRect)) {
                                self.failAudio.play();
                                self.gameOver();
                            }
                        };

                        // 빗방울 배열에서 제거하는 메소드
                        raindrop.onDie = function() {
                            for (let i = 0; i < self.raindrops.length ; i += 1){
                                if (self.raindrops[i] == raindrop) {
                                    self.raindrops.splice(i,1);
                                    break;
                                }
                            }
                        }

                        // 만들어진 새 빗방울은 배열에 추가
                        self.raindrops.push(raindrop);
                    }, randomRange(2000, 7000));

                    
                };

                /* 구름 만들기 */
                this.makeCloud = function(){
                    let self = this;
                    /* 구름 연속 생성 타이머 설정 메소드 */
                    this.cloudTimerId = setInterval(function(){
                        // 불투명도 랜덤 설정을 위해 불투명도 배열을 만들고 랜덤으로 선택하여 구름 만들 때 인자로 보내줌
                        cloudOpacitys = [0.7, 0.8, 0.9];
                        let cloud = new Cloud(self.element, STEP, cloudOpacitys[randomRange(0, cloudOpacitys.length)]);

                        // 만들어진 구름 배열에 추가
                        self.clouds.push(cloud);
                    }, randomRange(4000, 7000));
                };

                /* 눈사람 만들기 */
                this.makeSnowman = function(){
                    // Snowman은 한 번만 만들어져서 움직이지 않고, 움직이는 막대와 비교
                    this.snowman = new Snowman(this.element);

                    let self = this;
                    /* 제한 시간이 지나면 실행되는 메소드 */
                    this.snowman.timeout = function(){
                        //fail 사운드, 게임 오버
                        self.failAudio.play();
                        self.gameOver();
                    };
                };
                
                /* 막대와 아이템이 겹치는지 확인하는 메소드 */
                this.isOverlappedByBar = function(clientRect) {
                    let barRect = this.bar.getRectangle();

                    if (barRect.right < clientRect.left + GAP) return false;
                    if (barRect.left > clientRect.right - GAP) return false;
                    if (barRect.top > clientRect.bottom - GAP) return false;

                    return true;
                };

                /* 요소 사각형 반환 메소드 */
                this.getRectangle = function(){
                    return this.element.getBoundingClientRect();
                }

                /* 스코어 업데이트 메소드 */
                this.updateScore = function(incrementValue) {
                    //스코어 프로퍼티에 계속하여 point를 더해줌
                    this.score += incrementValue;
                    //스코어 요소의 text를 수정해줌
                    this.scoreElement.innerText = this.score;
                    //점수가 오르면 스테이지를 확인해줌
                    this.checkGameStage();
                };

               /* 스테이지 변경 메소드 */
               this.checkGameStage = function(){
                    /*
                    기준 스코어 이상을 달성하고 스테이지가 업데이트 되지 않았다면 스테이지 업데이트
                    스테이지마다 모두 clearAll 해주었으며 각각의 스테이지에 필요한 메소드 다시 실행
                    마지막 5 스테이지에서는 벽돌을 모두 깨게 되면 무한 게임이 되기 때문에
                    벽돌이 한 개 남았을 때 눈사람을 생성하여 엔딩을 만들어줌
                    */
                    if (this.score >= 30 && this.stage < 2){
                        //stage 2가 됨
                        this.stage = 2;
                        this.clearAll();
                        this.makeBricks();
                        this.makeLightning();
                        this.updateStage();
                    } else if (this.score >= 100 && this.stage < 3){
                        this.stage = 3;
                        this.clearAll();
                        this.makeBricks();
                        this.makeLightning();
                        this.makeRaindrop();
                        this.updateStage();
                    } else if (this.score >= 170 && this.stage < 4){
                        this.stage = 4;
                        this.clearAll();
                        this.makeBricks();
                        this.makeLightning();
                        this.makeRaindrop();
                        this.makeCloud();
                        this.updateStage();
                    } else if (this.score >= 250 && this.stage < 5){
                        this.stage = 5;
                        this.clearAll();
                        this.makeBricks();
                        this.makeLightning();
                        this.makeRaindrop();
                        this.makeCloud();
                        this.updateStage();
                    } else if (this.bricks.length == 1 && this.stage == 5) {
                        if(!this.snowman){
                            this.makeSnowman();
                        }
                    }
                };

                /* 스테이지 업데이트 할 때 all item clear 메소드 */
                this.clearAll = function(){
                    //ball timer clear
                    clearInterval(this.ball.ballTimerId);
                    //ball reset
                    this.ball.init();
                    //bar reset
                    this.bar.element.style.top = '585px';
                    this.bar.element.style.left = '290px';
                    //brick reset
                    for (let i = 0; i < this.bricks.length; i += 1){
                        this.bricks[i].remove();
                    }
                    //lightning timer clear & remove
                    clearInterval(this.lightningTimerId);
                    for (let i = 0; i < this.lightnings.length; i += 1){
                        this.lightnings[i].remove();
                    }
                    //raindrop timer clear & remove
                    clearInterval(this.raindropTimerId);
                    for (let i = 0; i < this.raindrops.length; i += 1){
                        this.raindrops[i].remove();
                    }
                    //cloud timer clear & remove
                    clearInterval(this.cloudTimerId);
                    for (let i = 0; i < this.clouds.length; i += 1){
                        this.clouds[i].remove();
                    }
                };

                /* 스테이지 업데이트 메소드 */
                this.updateStage = function(){
                    this.stageElement.innerText = 'stage' + this.stage;
                };

                /* 게임 종료 */
                this.gameOver = function(){
                    //sound
                    //ball timer clear
                    clearInterval(this.ball.ballTimerId);
                    this.ball.stop();
                    //lightning timer clear and stop
                    clearInterval(this.lightningTimerId);
                    for (let i = 0; i < this.lightnings.length; i += 1){
                        this.lightnings[i].stop();
                    }
                    //raindrop timer clear and stop
                    clearInterval(this.raindropTimerId);
                    for (let i = 0; i < this.raindrops.length; i += 1){
                        this.raindrops[i].stop();
                    }
                    //cloud timer clear and stop
                    clearInterval(this.cloudTimerId);
                    for (let i = 0; i < this.clouds.length; i += 1){
                        this.clouds[i].stop();
                    }
                    // snowman timers clear
                    if (this.snowman =! null){
                        this.snowman.clearTimers();
                    }
                    //stop bar moving
                    this.bar.ignoreKeyEvents();
                    //show top 3
                    this.showGameOverWindow();
                };

                //게임오버창 표시하기
                this.showGameOverWindow = function(){
                    // 게임오버창 요소와 현재스코어 텍스트 표시할 요소 불러오기
                    let gameOver = document.getElementById('gameOver');
                    let currentScore = document.getElementById('currentScore');
                    // 현재스코어 요소에 score 추가해주기
                    currentScore.innerText = 'Your score is ' + this.score;
                    // 기존의 스코어와 비교하여 최종 top 3 스코어를 받기
                    let scores = this.checkScores();
                    // 창에 Top 3 스코어 표시
                    for (let i = 0; i < scores.length; i += 1){
                        let para = document.createElement('p');
                        para.innerText = `Top#${i+1}: ${scores[scores.length - i - 1]}`;
                        gameOver.appendChild(para);
                    }

                    //창이 0.9의 투명도로 보이도록 설정
                    gameOver.style.display = 'block';
                    this.element.style.opacity = '0.9';
                };

                
                //스코어 체크하기
                this.checkScores = function(){
                    //로컬스토리지 조회해서 배열에 넣기
                    let scores = localStorage.getItem(SCORE_ARRAY);
                    //scores가 null, false, undefined이면 값이 들어옴
                    if (!scores) {
                        scores = [];
                        //배열을 로컬스토리지에 등록
                        localStorage.setItem(SCORE_ARRAY, JSON.stringify(scores));
                    } else {
                        //배열이 들어있었다면 받기
                        scores = JSON.parse(scores);
                    }

                    //필요하면 저장하기
                    if (scores.length < MAX_SCORES) {
                        scores.push(this.score);
                    } else {
                        scores = scores.sort((function(a,b){return a-b}));
                        // 현재 스코어가 기존의 3등보다 작아서 저장할 필요가 없으면 그대로 리턴
                        if (parseInt(scores[0]) > this.score){
                            return scores;
                        }
                        // 세번째 보다 크면 저장 배열에 저장
                        scores[0] = this.score;
                    }
                    //로컬스토리지에 저장함
                    localStorage.setItem(SCORE_ARRAY, JSON.stringify(scores));
                    return scores.sort(function(a,b){return a-b});
                }


                /* 초기 설정 실행 */
                this.init();
            }

            /* 랜덤 함수 */
            function randomRange(n1, n2) {
                return Math.floor((Math.random() * (n2 -n1 + 1)) + n1);
            }

        </script>
    </head>
    <body>
        <h1><span>B</span>reackout <span>G</span>ame</h1>
        <div id="stage">stage 1</div>
        <div id="score">00</div>
        <div id="board">
            <div id="bar"></div>
            <div id="ball"></div>
            <div id="brick"></div>
            <!--
            <div class="lightning"></div>
            <div class="raindrop"></div>
            <div class="worm"></div>
            <div class="snowman"></div>
            -->
            <div id = "gameOver">
                <p id="currentScore">240</p>
                <!--
                <p>Top #1 : 3000</p>
                <p>Top #2 : 3000</p>
                <p>Top #3 : 3000</p>
                -->
            </div>
        </div>
        <audio class="ball">
            <source src = "sound/ball.wav" type="audio/wav">
        </audio>
        <audio class="item">
            <source src = "sound/lightning.wav" type="audio/wav">
        </audio>
        <audio class="fail">
            <source src = "sound/fail.wav" type="audio/wav">
        </audio>
        <audio class="ending">
            <source src = "sound/ending.wav" type="audio/wav">
        </audio>
    </body>
</html>